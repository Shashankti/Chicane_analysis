---
title: "Analysis of Chicane Results"
author: "Shashank Tiwari"
date: "Updated<br> `r Sys.Date()`"
output: 
  rmarkdown::html_document: 
    theme: spacelab
    highlight: zenburn 
    code_folding: show 
    toc: true 
    toc_float: true
    smooth_scroll: true
    number_sections: false 
    self_contained: true 
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=T, message=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  dpi=350,
  fig.height = 6,
  fig.width = 7.00787 #178mm
)  
knitr::opts_chunk$set(warning = FALSE) 
options(knitr.duplicate.label = "allow")
#Input
library(knitr)
library(png)
library(gridExtra)
library(ggplot2)
library(GenomicRanges)
library(chicane)
library(data.table)
library(dplyr)
library(stringr)
library(cowplot)
library(viridis)
library(slickR)
library(svglite)
library(patchwork)
library(magick)
library(DT)
```

# Initial Observations

We look to analyse the ouput from the initial chicane run. Compare the results from the previous Chicago run.

# Introduction to the Chicane

CHiCANE was designed to identify regions of interest that interact more than expected by chance. To indetify the interaction peaks, CHiCANE models the expected number of reads linking two restriction fragments as a function of the distance between the loci and the 'interactibility' of the bait fragment; that is, its inherent propensity to interact with other fragments.

Let $Y_{ij}$ represent the count of interactions between a bait $i$ and a fragment $j$,$d_{ij}$ be the distance between the bait and the otherEnd and $t_{i}$ denote the number of reads linking a bait $i$ with another fragment in trans. $Y_{ij}$ is such that it is assumed to follow a distribution with a mean $\mu_{ij}$ as: $$ \mu_{ij} = \beta_0 + \beta_1 \log(d_{ij}) + \beta_2 \log(t_i+1) $$

For bait to bait interactions, terms are added to the model to adjust for trans counts of the other end, fragment j, and the product of trans counts of both fragments as: $$ \mu_{ij} = \beta_0 + \beta_1 \log(d_{ij}) + \beta_2 \log(t_i+1)  + \beta_3 \log(t_j + 1) + \beta_4 \log(t_i +1) \log(t_j+1)$$ Each possible interaction is assaigned an expected $\mu_{ij}$ and a p-value for the observed counts $y_{ij}$ versus what is expected by chance is calculated as: $$p = P(Y_{ij} \geq y_{ij})$$

# Example data

The example data used here is from the T47D human breast cancer cells. The input files used for the `Chicane` run were the output from the CHi-C libraries generated in the ER+ breast cancer cell line.

Let us first look at plots from the example data set provided with the chicane paper.

```{r}
# Read example data file
ex = fread("/home/master/shared_folder/radicl_seq/Data/Raw/CHiCANE_Supplementary_Data/data/chicane/T47D/interaction_calls1.txt.gz",header=TRUE,stringsAsFactors = FALSE,quote = "",select = c("distance","count","p.value","q.value"))
# Significant interactions
ex_signif <- ex[ex$q.value<0.05]
```

Adjusting for including the correct counts.

```{r}
ex_stretch <- ex[!is.na(q.value),.(count2=1:count),names(ex)]

```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
p34 = ggplot(ex[is.na(ex$distance)],aes(count,log(q.value,base=10)))+
  geom_point(color="#69b3a2",size=0.5,alpha=0.3)+
  theme_cowplot()+
  ggtitle("Count distribution of trans interaction for example data ")+
  theme(plot.title = element_text(size = 10))
```

## Score distribution of example data

This is the output for the example data. A threshold of 0.05 is used to determine significant interactions.

```{r}
exp_d = ggplot(ex_stretch,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for example data")+
  theme_cowplot()+
  xlab("q.value")+
  theme(plot.title = element_text(size = 10))
plot(exp_d)
```

```{r}
ex_stretch_cis <- ex[!is.na(distance),.(count2=1:count),names(ex)]
ex_stretch_trans <- ex[is.na(distance),.(count2=1:count),names(ex)]

ex_signif_stretch <- ex_signif[!is.na(distance),.(count2=1:count),names(ex_signif)]
```

### Cis vs Trans interactions

```{r,fig.show="hold",out.width="50%",fig.cap="Distribution of q.value",message=FALSE}
##Cis-trans-ex_plot
par(mar=c(4,4,.1,.1))


exp_cis = ggplot(ex_stretch_cis,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for example data(Cis)")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))+
  xlab("q.value")

exp_trans = ggplot(ex_stretch_trans,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for example data(Trans)")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))+
  xlab("q.value")
plot(exp_cis)
plot(exp_trans)
```

```{r,echo=FALSE,message=FALSE,results='hide'}
gc()
```

## Correlation plot

We plot the correlation between the observed p.value and the counts of interaction for example data. Note that the p.value here is unweighted.

```{r,message=FALSE,fig.show="hold",out.width="50%",fig.cap="Cis vs Trans",eval=FALSE}
par(mar=c(4,4,.1,.1))

cor_test_trans <- cor.test(ex[is.na(ex$distance)]$count,ex[is.na(ex$distance)]$p.value,method = "spearman",exact = F)
plt_text_trans <- paste0('r = ', round(cor_test_trans$estimate,3), ', ',
                paste('p-value < 2.2e-16'))#taken from res of cor_test
setorder(ex[is.na(ex$distance)],distance)
p11 = ggplot(data=ex[is.na(ex$distance)],aes(x = log(count,base=10), 
                      y = log(p.value,base=10),colour=distance))+ 
  geom_point(alpha=0.2,size=0.1) + 
  geom_smooth(method = "lm", se = T,color = 'grey20', alpha = 0.2,size=0.5) +
  annotate('text', x = -Inf, y = Inf, hjust = -.1, vjust = 1  ,label=plt_text_trans)+
  labs(y= "Log 10 P-Value", x = "Log 10 Interaction Counts(Trans)")  +
  theme_cowplot()+
  ggtitle("Example Data-Trans inetractions")+
  scale_color_viridis()

cor_test <- cor.test(ex[!is.na(ex$distance)]$count,ex[!is.na(ex$distance)]$p.value,method = "spearman",exact = F)
plt_text <- paste0('r = ', round(cor_test$estimate,3), ', ',
                paste('p-value < 2.2e-16'))#taken from res of cor_test
setorder(ex[!is.na(ex$distance)],distance)
p12 = ggplot(ex[!is.na(ex$distance)] ,aes(x = log(count,base=10), 
                      y = log(p.value,base=10),colour=distance))+ 
  geom_point(alpha=0.2,size=0.1) + 
  geom_smooth(method = "lm", se = T,color = 'grey20', alpha = 0.2,size=0.5) +
  annotate('text', x = -Inf, y = Inf, hjust = -.1, vjust = 1  ,label=plt_text)+
  labs(y= "Log 10 P-Value", x = "Log 10 Interaction Counts(Cis)")  +
  theme_cowplot()+
  ggtitle("Example Data-Cis inetractions")+
  scale_color_viridis()
plot(p11)
plot(p12)
```

```{r,echo=FALSE}
p1 <- ggdraw()+draw_image("trans-ex.png")
p2 <- ggdraw()+draw_image("cis-ex.png")
(p1 | p2)
```

## Distance distibution for example data

We look at the counts of distance for the interactions.

```{r,echo=FALSE,message=FALSE,results='hide'}
rm(ex)
rm(exp_cis)
rm(exp_trans)
gc()
```

```{r}
ggplot(ex_stretch_cis,aes(ex_stretch_cis$distance))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Distribution of distance for example data")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))+
  xlab("distance")
```

### Significant interactions

Filtering this data for the significant interactions.

```{r}
ggplot(ex_signif_stretch,aes(ex_signif_stretch$distance))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Distribution of distance for example data")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))+
  xlab("distance")
```

```{r,echo=FALSE,message=FALSE,results='hide'}
rm(ex_stretch_cis)
rm(ex_stretch)
gc()
```

# Radicl-seq data

```{r}

#Read output data file
ibed <- fread("/home/master/radicl_seq/Run_chicago/Data/chicane.results.rdcl.txt",header=TRUE,stringsAsFactors = FALSE,quote = "")
#Remove NA entries
ibed <- ibed[!is.na(ibed$p.value)]

#Read transcript file
baits <- fread("/home/master/shared_folder/radicl_seq/Data/Raw/all_genes_location.txt",header = FALSE,stringsAsFactors = FALSE)
colnames(baits) <- c("chr","start","end","bait_name")
baits$mid <- 0.5*(baits$end-baits$start)
ibed$bait_name <- baits$bait_name[match(ibed$bait.start,baits$start)]
signif <-ibed[ibed$q.value<0.05,]
cis_signif <- signif[!is.na(signif$distance)]
ibed <- ibed[,12:17]
q.count <- quantile(cis_signif$count,c(0.30,0.60,0.90,0.99))
cis_signif$q.count <- with(cis_signif,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))
cis_signif_wo <- cis_signif[!cis_signif$bait_name=="MALAT1"]
cis_signif_wo <- cis_signif_wo[!cis_signif_wo$bait_name=="NEAT1"]
q.count <- quantile(cis_signif_wo$count,c(0.30,0.60,0.90,0.99))
cis_signif_wo$q.count <- with(cis_signif_wo,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))
```

```{r,echo=FALSE,warning=FALSE,message=FALSE}
gc()
```

```{r}

ibed_stretch_cis <- ibed[!is.na(distance),.(count2=1:count),names(ibed)]
ibed_stretch_trans <- ibed[is.na(distance),.(count2=1:count),names(ibed)]
ibed_stretch <- rbind(ibed_stretch_trans,ibed_stretch_cis)

ibed_signif_stretch <- signif[!is.na(distance),.(count2=1:count),names(signif)]
```

## Score distribution for radicl-seq.

Let us first look at the scores for radicl-seq.

```{r}
ggplot(ibed_stretch,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for radicl-seq")+
  theme_cowplot()
```

### Without MALAT1 and NEAT1

`r 100*length(ibed_stretch[ibed_stretch$bait_name=="MALAT1" | ibed_stretch$bait_name=="NEAT1"]$distance)/length(ibed_stretch$distance)` % of interactions observed are from MALAT1 and NEAT1. We remove those interactions from the data set and compare the results

```{r}
without_ibed <- ibed_stretch[!ibed_stretch$bait_name=="MALAT1"]
without_ibed <- without_ibed[!without_ibed$bait_name=="NEAT1"]


wo_mn <- ibed[!ibed$bait_name=="MALAT1"]
wo_mn <- wo_mn[!wo_mn$bait_name=="NEAT1"]
ggplot(without_ibed,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution without MALAT1 and NEAT1")+
  theme_cowplot()
```

### Cis vs trans interactions

Since majority of interactions detected are trans interactions we would like compare how is the distribution of q.value in both the cases.

```{r,fig.show="hold",out.width="50%",fig.cap="Distribution of q.value"}
##Cis-trans-ex_plot
par(mar=c(4,4,.1,.1))
ggplot(ibed_stretch_cis,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for data(Cis)")+
  theme_cowplot()

ggplot(ibed_stretch_trans,aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef", alpha=0.8)+
  ggtitle("Score distribution for data(Trans)")+
  theme_cowplot()
```

```{r,echo=FALSE,message=FALSE,results='hide'}
gc()
```

### Without MALAT1 and NEAT1

```{r,fig.show="hold",out.width="50%",fig.cap="Distribution of q.value"}
##Cis-trans-ex_plot
par(mar=c(4,4,.1,.1))
ggplot(without_ibed[!is.na(without_ibed$distance)],aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for data(Cis)")+
  theme_cowplot()

ggplot(without_ibed[is.na(without_ibed$distance)],aes(q.value))+
  geom_histogram(fill="#69b3a2", color="#e9ecef", alpha=0.8)+
  ggtitle("Score distribution for data(Trans)")+
  theme_cowplot()
```

## Distance distribution

```{r}
ggplot(ibed_stretch_cis,aes(distance))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Distribution of distance for radicl-seq")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))
```

### Without MALAT1 and NEAT1

```{r}
ggplot(without_ibed,aes(distance))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Distribution of distance without MALAT1 and NEAT1")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))
```

### Significant interactions

A total of `34627` interactions are significant. This accounts for `0.2954271 %` of all interactions. However when we take into account the number of counts from each interaction as well, a total of `3.567306%` interactions are significant.

Out of these significant interactions MALAT1 and NEAT1 account for `r length(ibed_signif_stretch[ibed_signif_stretch$bait_name=="MALAT1"|ibed_signif_stretch$bait_name=="NEAT1"]$target.id)/length(ibed_signif_stretch$distance)*100` Filtering this data for the significant interactions.

```{r}

ggplot(ibed_signif_stretch,aes(distance))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Distribution of distance for radicl-seq")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))
```

### Without MALAT1 and NEAT1

```{r}
ggplot(without_ibed[without_ibed$q.value<0.05],aes(distance))+
  geom_histogram(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Distribution of distance without MALAT1 and NEAT1")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))
```

## Distance relation of q.value

Next we look at the distribution of the q,value with the distance and the counts.

```{r}
p1 = ggplot(cis_signif %>% arrange(q.count),aes(x=distance,y=log(q.value,base=10)))+
  geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+
    xlab("distance")+
  ylab("log.q.value")+
  theme_cowplot()+
  ggtitle("q.value distribution of significant interactions")+
  theme(plot.title = element_text(size = 10))


p2 = ggplot(cis_signif_wo %>% arrange(q.count),aes(x=distance,y=log(q.value,base=10)))+
  geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","red"),labels=c("0-30","99-100"))+
    xlab("distance")+
  ylab("log.q.value")+
  theme_cowplot()+
  ggtitle("q.value distribution of significant interactions without MALAT1 and NEAT1")+
  theme(plot.title = element_text(size = 10))

p3 = ggplot(ex_signif %>% arrange(count),aes(x=ex_signif$distance ,y=log(ex_signif$q.value,base=10),color=log(ex_signif$count,base=10)))+
    scale_color_gradient(high="red",low="#69b3a2",name="log.count")+
   geom_point(size=0.5,alpha=0.5)+
    theme_cowplot()+
  xlab("distance")+
  ylab("log.q.value")+
  ggtitle("q.value distribution of significant interactions for example data")+
  theme(plot.title = element_text(size = 10))

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)
p3 = xmlSVG({show(p3)}, standalone = TRUE)


slickR(list(p1, p2,p3))+settings(dots=TRUE,autoplay = TRUE)
```

```{r,echo=FALSE,message=FALSE,results='hide'}
rm(ibed_stretch_cis)
rm(ibed_stretch_trans)
gc()
```

# Correlation plot

```{r,echo=FALSE,message=FALSE,results='hide'}
gc()
```

```{r,message=FALSE,fig.show="hold",out.width="50%",fig.cap="Cis vs Trans",eval=FALSE}
par(mar=c(4,4,.1,.1))
cor_test <- cor.test(ibed[is.na(ibed$distance)]$count,ibed[is.na(ibed$distance)]$p.value,method = "spearman",exact = F)
plt_text <- paste0('r = ', round(cor_test$estimate,3), ', ',
                paste('p-value < 2.2e-16'))#taken from res of cor_test
setorder(ibed[is.na(ibed$distance)],distance)
ggplot(data=ibed[is.na(ibed$distance)],aes(x = log(count,base=10), 
                      y = log(p.value,base=10),colour=distance))+ 
  geom_point(alpha=0.2,size=0.1) + 
  geom_smooth(method = "lm", se = T,color = 'grey20', alpha = 0.2,size=0.5) +
  annotate('text', x = -Inf, y = Inf, hjust = -.1, vjust = 1  ,label=plt_text)+
  labs(y= "Log 10 P-Value", x = "Log 10 Interaction Counts(Trans)")  +
  theme_cowplot()+
  ggtitle("Trans inetractions")+
  scale_color_viridis()

cor_test <- cor.test(ibed[!is.na(ibed$distance)]$count,ibed[!is.na(ibed$distance)]$p.value,method = "spearman",exact = F)
plt_text <- paste0('r = ', round(cor_test$estimate,3), ', ',
                paste('p-value < 2.2e-16'))#taken from res of cor_test
setorder(ibed[!is.na(ibed$distance)],distance)
ggplot(ibed[!is.na(ibed$distance)] %>% arrange(distance),aes(x = log(count,base=10), 
                      y = log(p.value,base=10),colour=distance))+ 
  geom_point(alpha=0.2,size=0.1) + 
  geom_smooth(method = "lm", se = T,color = 'grey20', alpha = 0.2,size=0.5) +
  annotate('text', x = -Inf, y = Inf, hjust = -.1, vjust = 1  ,label=plt_text)+
  labs(y= "Log 10 P-Value", x = "Log 10 Interaction Counts(Cis)")  +
  theme_cowplot()+
  ggtitle("Cis inetractions")+
  scale_color_viridis()
```

```{r,echo=FALSE,fig.show="hold",out.width="50%"}
par(mar=c(4,4,.1,.1))
img3_path <- "radicl-cis.png"
img4_path <- "radicl-trans.png"
include_graphics(img3_path)
include_graphics(img4_path)

```

```{r,echo=FALSE,message=FALSE,results='hide'}
gc()
```

## Without MALAT1 and NEAT1

```{r,message=FALSE,fig.show="hold",out.width="50%",fig.cap="Cis vs Trans"}
par(mar=c(4,4,.1,.1))

cor_test <- cor.test(wo_mn[is.na(wo_mn$distance)]$count,wo_mn[is.na(wo_mn$distance)]$p.value,method = "spearman",exact = F)
plt_text <- paste0('r = ', round(cor_test$estimate,3), ', ',
                paste('p-value < 2.2e-16'))#taken from res of cor_test
setorder(wo_mn[is.na(wo_mn$distance)],distance)
ggplot(data=wo_mn[is.na(wo_mn$distance)],aes(x = log(count,base=10), 
                      y = log(p.value,base=10),colour=distance))+ 
  geom_point(alpha=0.2,size=0.1) + 
  geom_smooth(method = "lm", se = T,color = 'grey20', alpha = 0.2,size=0.5) +
  annotate('text', x = -Inf, y = Inf, hjust = -.1, vjust = 1  ,label=plt_text)+
  labs(y= "Log 10 P-Value", x = "Log 10 Interaction Counts(Trans)")  +
  theme_cowplot()+
  ggtitle("Trans inetractions without MALAT1 and NEAT1")+
  scale_color_viridis()

cor_test <- cor.test(wo_mn[!is.na(wo_mn$distance)]$count,wo_mn[!is.na(wo_mn$distance)]$p.value,method = "spearman",exact = F)
plt_text <- paste0('r = ', round(cor_test$estimate,3), ', ',
                paste('p-value < 2.2e-16'))#taken from res of cor_test
setorder(wo_mn[!is.na(wo_mn$distance)],distance)
ggplot(wo_mn[!is.na(wo_mn$distance)] %>% arrange(distance),aes(x = log(count,base=10), 
                      y = log(p.value,base=10),colour=distance))+ 
  geom_point(alpha=0.2,size=0.1) + 
  geom_smooth(method = "lm", se = T,color = 'grey20', alpha = 0.2,size=0.5) +
  annotate('text', x = -Inf, y = Inf, hjust = -.1, vjust = 1  ,label=plt_text)+
  labs(y= "Log 10 P-Value", x = "Log 10 Interaction Counts(Cis)")  +
  theme_cowplot()+
  ggtitle("Cis inetractions")+
  scale_color_viridis()
```

```{r,echo=FALSE,fig.show="hold",out.width="50%"}
par(mar=c(4,4,.1,.1))
img1_path <- "trans-ex.png"
img2_path <- "cis-ex.png"
include_graphics(img1_path)
include_graphics(img2_path)

```

```{r,echo=FALSE,message=FALSE,results='hide'}
rm(without_ibed)
rm(exp_d)
rm(p1)
rm(p2)
gc()
```

## q.value vs count

It should be noted that majority of the interactions in radicl-seq are trans interactions(`r length(which(is.na(ibed$distance)))*100/length(ibed$bait.id)`), therefore the distance relation of the score for significant inteactions can not be visualized easily here.

```{r,echo=FALSE}
p1 <- ggdraw()+draw_image("count.jpeg")
p2 <- ggdraw()+draw_image("count_wo.jpeg")
p3 <- ggdraw()+draw_image("ex_count.jpeg")
(p1 | p2) / 
  p3
```

```{r,echo=FALSE,warning=FALSE,message=FALSE,results='hide'}
rm(p34)
gc()
```






# Attempt to apply p-value weighting from CHiCAGO

CHiCAGO uses a p-value weighting method to filter out erroneous calls, Chicane on the other hand applies the Benjamini & Hochberg method for multiple testing correction. However this method applies a stringent p-value threshold and may thus disregard the long range false positive but this might also result in removing many short range true positives. To test this hypothesis we can apply the p-value wieghting method here and compare the results.

```{r,eval=FALSE,results='hide'}
ibed <-getScores(ibed)
getScores <- function(ibed)
  {
  ## - If method="weightedRelative", we divide by weights (Genovese et al 2006)
  ##Note to self: Algebra is on P96 of my lab notebook.
  
  avgFragLen <- .getAvgFragLength(ibed) ##average fragment length
  
  
    eta.bar <- .getEtaBar(ibed)
    ibed$log.p <- log10(ibed$p.value)
    
    ##Get weights, weight p-values
    message("Calculating p-value weights...")
    ibed[, log.w:= .getWeights(abs(ibed$distance), ibed, eta.bar=eta.bar)]
    ibed[, log.q:= log.p - log.w] ##weighted p-val
    message("Calculating scores...")
    
    ##get score (more interpretable than log.q)
    minval <- .getWeights(0, ibed, eta.bar=eta.bar) ##FIXME could be optimized a *lot*.
    ibed[,score := pmax(- minval - log.q, 0)]
    
  ibed
}

.getAvgFragLength <- function(ibed)
{
  ##Normally, takes rmapfile from cd object.
  ##However, if rmapfile is specified, this overrides cd.
  
  rmap <- unique(ibed[,3:5])
  chrMax <- rmap[,max(target.end),by="target.chr"] ##length of each chr
  sum(as.numeric(chrMax$V1))/nrow(rmap)
}

.getNoOfHypotheses <- function(ibed)
{
  
  ##How many hypotheses are we testing? (algebra on p246 of JMC's lab notebook)
  rmap <- unique(ibed[,3:5])
  chrMax <- rmap[,max(target.end),by="target.chr"] ##length of each chr
  baitmap <- unique(ibed[,6:8])
  nBaits <- table(baitmap$bait.chr)
  avgFragLen <- .getAvgFragLength(ibed) ##average fragment length
  
  chr <- chrMax$target.chr
  ##count # of hypotheses
  Nhyp <- sum(nBaits)*(2*nrow(rmap) - sum(nBaits) - 1)/2L ##number of hypotheses being tested
  Nhyp
}
set <- example@settings
.getEtaBar <- function(cd, includeTrans=TRUE)
{
  
  ##1. Collect parameters
  alpha = set$weightAlpha
  beta = set$weightBeta
  gamma = set$weightGamma
  delta = set$weightDelta
  
  ##2. Get genomic/fragment map information
  rmap <- unique(ibed[,3:5])
  chrMax <- rmap[,max(target.end),by="target.chr"] ##length of each chr
  baitmap <- unique(ibed[,6:8])
  nBaits <- table(baitmap$bait.chr)
  
  
  chr <- as.character(names(nBaits))
  
  avgFragLen <- .getAvgFragLength(ibed)
  
  ##count # of hypotheses
  Nhyp <- .getNoOfHypotheses(ibed)
  
  ##3. Calculate eta.bar
  ##Loop, summing contributions of eta
  
  eta.sigma <- 0 
  for(c in chr)
  {
    ##length of chromosome
    d.c <- as.numeric(chrMax$V1[chrMax$target.chr == c])
    ##no of baits on chromosome
    n.c <- nBaits[c]
    
    for(i in 1:n.c) ##TODO nested for loop can be replaced with lapply & function
    {
      d = d.c*i/n.c
      d.near = min(d, d.c-d) ##dist to nearest chromosome end
      d.other <- seq(from=avgFragLen, to=max(avgFragLen,d.near), by = avgFragLen) ##locations of fragments
      d.other2 <- seq(from=d.near, to=d.c-d.near, by = avgFragLen)
      eta.sigma <- eta.sigma + 2*sum(expit(alpha + beta*log(d.other))) + sum(expit(alpha + beta*log(d.other2)))
      #eta[i] <- 2*sum(expit(alpha + beta*log(d.other))) + sum(expit(alpha + beta*log(d.other2)))
    }
  }
  
  eta.bar <- eta.sigma/Nhyp
  eta.bar
}

.getWeights <- function(dist,ibed,eta.bar)
{
  alpha = set$weightAlpha
  beta = set$weightBeta
  gamma = set$weightGamma
  delta = set$weightDelta
  
  ##4. Calculate weights
  eta <- expit(alpha + beta*log(naToInf(dist)))
  log.w <- log((expit(delta) - expit(gamma))*eta + expit(gamma)) -
    log((expit(delta) - expit(gamma))*eta.bar + expit(gamma))
  
  log.w
}




## Misc functions ---------------------------

wb2b = function(oeID, s, baitmap=NULL){
  # s is the current chicagoData object's settings list
  if (is.null(baitmap)){
    baitmap = .readBaitmap(s)
  }
  which(oeID %in% baitmap[[s$baitmapFragIDcol]])
}

whichbait2bait = function(x, baitmap=NULL){
  stop("whichbait2bait is deprecated. Use wb2b instead")
}

as.dataTableList <- function(cd){ 
  # takes a list of chicagoData objects cd and returns a list of data tables 
  # from the respective cd@x slots
  lapply(cd, function(cdi)cdi@x)
}

geo_mean <- function(data){    
  log_data <- log(data);    
  gm <- exp(mean(log_data[is.finite(log_data)]));    
  return(gm) 
} # http://stackoverflow.com/questions/2602583/geometric-mean-is-there-a-built-in

logit <- function(p){log(p/(1-p))}

expit <- function(x){1/(1+exp(-x))}

removeNAs <- function(x) {x[!is.na(x)]}

naToInf <- function(x)
{
  ifelse(is.na(x), Inf, x) ##Convert NAs to infs.
}

ifnotnull = function(var, res){ if(!is.null(var)){res}}

locateFile = function(what, where, pattern){
  message("Locating ", what, " in ", where, "...")
  filename = list.files(where, pattern)
  
  if (length(filename)!=1){
    stop(paste0("Could not unambigously locate a ", what, " in ", where, ". Please specify explicitly in settings\n"))
  }
  
  message("Found ", filename)
  file.path(where, filename)
}
```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
load("score.RData")
ibed$frag.len <- ibed$target.end-ibed$target.start
ibed_stretch_cis <- ibed[!is.na(distance),.(count2=1:count),names(ibed)]
ibed_stretch_trans <- ibed[is.na(distance),.(count2=1:count),names(ibed)]
ibed_stretch <- rbind(ibed_stretch_trans,ibed_stretch_cis)

ibed_signif_stretch <- signif[!is.na(distance),.(count2=1:count),names(signif)]
without_ibed <- ibed_stretch[!ibed_stretch$bait_name=="MALAT1"]
without_ibed <- without_ibed[!without_ibed$bait_name=="NEAT1"]


wo_mn <- ibed[!ibed$bait_name=="MALAT1"]
wo_mn <- wo_mn[!wo_mn$bait_name=="NEAT1"]
```

Significant interactions can be sorted out based on a threshold of score\>5. On comparing the significant interactions obtained from the q.value threshold and p-value weighted score threshold we can observer that q.value threshold removes far less interaction when compared with the `score`.

## Comparision of distance distibution of significant interaction

```{r}
#Filtering significant
chic_signif <- ibed[ibed$score>5]
ggplot(data = ibed_stretch_cis)+
  geom_density(data=ibed_stretch_cis[ibed_stretch_cis$q.value<0.05],
               aes(log10(distance),fill="q.value"),alpha=0.3)+
  geom_density(data = ibed_stretch_cis[ibed_stretch_cis$score>5],
               aes(log10(distance),fill="score"),alpha=0.2)+
  scale_fill_manual(values = c(q.value = '#69b3a2',score = '#F06C64'),
                    labels=c("q.value","score"))+
  ggtitle("Distribution of distance for significant interactions in radicl-seq")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))


```

### Without MALAT1 and NEAT1

```{r}
ggplot(data = without_ibed)+
  geom_density(data=without_ibed[without_ibed$q.value<0.05],
               aes(log10(distance),fill="q.value"),alpha=0.3)+
  geom_density(data = without_ibed[without_ibed$score>5],
               aes(log10(distance),fill="score"),alpha=0.2)+
  scale_fill_manual(values = c(q.value = '#69b3a2',score = '#F06C64'),
                    labels=c("q.value","score"))+
  ggtitle("Distribution of distance for significant interactions without MALAT1 and NEAT1")+
  theme_cowplot()+
  theme(plot.title = element_text(size = 10))

```
## Comparision of counts
```{r}
#Filtering significant
ggplot(data = ibed_stretch_cis)+
  geom_density(data=ibed_stretch_cis[ibed_stretch_cis$q.value<0.05],
               aes(log10(count),fill="q.value"),alpha=0.3)+
  geom_density(data = ibed_stretch_cis[ibed_stretch_cis$score>5],
               aes(log10(count),fill="score"),alpha=0.2)+
  scale_fill_manual(values = c(q.value = '#69b3a2',score = '#F06C64'),
                    labels=c("q.value","score"))+
  ggtitle("Distribution of counts for significant interactions in radicl-seq")+
  theme_cowplot()+
  xlim(0,5)+
  theme(plot.title = element_text(size = 10))

```

### Without MALAT1 and NEAT1

```{r}
ggplot(data = without_ibed)+
  geom_density(data=without_ibed[without_ibed$q.value<0.05],
               aes(log10(count),fill="q.value"),alpha=0.3)+
  geom_density(data = without_ibed[without_ibed$score>5],
               aes(log10(count),fill="score"),alpha=0.2)+
  scale_fill_manual(values = c(q.value = '#69b3a2',score = '#F06C64'),
                    labels=c("q.value","score"))+
  ggtitle("Distribution of distance for significant interactions without MALAT1 and NEAT1")+
  theme_cowplot()+
  xlim(0,5)+
  theme(plot.title = element_text(size = 10))

```

We can further compare the significant interactions from both multiple testing procedures.

```{r}
DT::datatable(chic_signif[,c(1,2,12,13,16,22,17)])
```

```{r,out.width="50%",fig.show='hold',include=FALSE,echo=FALSE}
p1 = ggplot(ibed[!is.na(ibed$distance) & ibed$score>5] %>% arrange(score),aes(x=distance,y=count))+
  geom_point(size=0.3,alpha=0.3,
             aes(color =log10(score))) +
  scale_colour_viridis() + 
   xlab("distance")+
  ylab("count")+
  theme_cowplot()+
  ggtitle("Significant interactions based on score approach")+
  theme(plot.title = element_text(size = 10))
p2 = ggplot(ibed[!is.na(ibed$distance) & ibed$q.value<0.05] %>% arrange(log10(-q.value)),aes(x=distance,y=count))+
  geom_point(size=0.3,alpha=0.3,aes(color = log10(q.value))) +
  scale_color_viridis_c()+
   xlab("distance")+
  ylab("count")+
  theme_cowplot()+
  ggtitle("Significant interactions based on q.value approach")+
  theme(plot.title = element_text(size = 10))
plot(p1)
plot(p2)
```

A total of `r 100*length(chic_signif_cis$target.id)/length(chic_signif$target.id)` % interactions are cis interactions using the alternative approach, compared with the `r 100*length(signif[!is.na(signif$distance)]$target.id)/length(signif$target.id)`.

The mean distance for the score approach is `r mean(chic_signif_cis$distance,na.rm=TRUE)`, compared with `r mean(signif[!is.na(signif$distance)]$distance)`.

It can also be seen that the filtered interactions from the 'score' apporach is a subset of the interactions from 'q.value' approach.

```{r}
DT::datatable(signif[signif$score<5][,c(1,2,12,13,16,22,17)])
```

In these interactions. `r 100*length(signif[signif$score<5 & !is.na(signif$distance)]$target.id)/length(signif[signif$score<5]$target.id)`% are cis interactions, with a mean distance of `r mean(signif[signif$score<5 & !is.na(signif$distance)]$distance)`. Therefore it can be seen that interaction with higher distance are being downweighted when using this approach.

```{r}
p1 = ggplot(signif[signif$score<5 & is.na(signif$distance)] %>% arrange(distance),aes(x=log10(q.value),y=score,base=10))+
  geom_point(aes(color=distance),size=0.5,alpha=0.3)+
    scale_colour_viridis()+
    xlab("log10 q.value")+
  theme_cowplot()+
  ggtitle("Outlier trans interactions")+
  theme(plot.title = element_text(size = 10))
p2 = ggplot(signif[signif$score<5 & !is.na(signif$distance)] %>% arrange(distance),aes(x=log10(q.value),y=score))+
  geom_point(aes(color=distance),size=0.5,alpha=0.3)+
    scale_colour_viridis()+
    xlab("log10 q.value")+
  theme_cowplot()+
  ggtitle("Outlier cis interactions")+
  theme(plot.title = element_text(size = 10))
p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)


slickR(list(p1, p2))+settings(dots=TRUE,autoplay = TRUE)

```

## Score distribution

```{r}
ggplot(ibed_stretch,aes(log10(score)))+
  geom_density(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for radicl-seq")+
  geom_vline(xintercept = log10(5),color="grey")+
  annotate(x=log10(5),y=2,label="score=5",vjust=2,geom ="label")+
  theme_cowplot()
```

### Without MALAT1 and NEAT1

```{r}
ggplot(without_ibed,aes(log10(score)))+
  geom_density(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution without MALAT1 and NEAT1")+
  geom_vline(xintercept = log10(5),color="grey")+
  annotate(x=log10(5),y=2,label="score=5",vjust=2,geom ="label")+
  theme_cowplot()
```

### Cis vs trans interactions

```{r,fig.show="hold",out.width="50%",fig.cap="Distribution of score"}
##Cis-trans-ex_plot
par(mar=c(4,4,.1,.1))
ggplot(ibed_stretch_cis,aes(log10(score)))+
  geom_density(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for data(Cis)")+
  geom_vline(xintercept = log10(5),color="grey")+
  annotate(x=log10(5),y=2,label="score=5",vjust=2,geom ="label")+
  theme_cowplot()

ggplot(ibed_stretch_trans,aes(log10(score)))+
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)+
  ggtitle("Score distribution for data(Trans)")+
  geom_vline(xintercept = log10(5),color="grey")+
  annotate(x=log10(5),y=2,label="score=5",vjust=2,geom ="label")+
  theme_cowplot()
```

```{r,echo=FALSE,message=FALSE,results='hide'}
gc()
```

#### Without MALAT1 and NEAT1

```{r,fig.show="hold",out.width="50%",fig.cap="Distribution of q.value"}
##Cis-trans-ex_plot
par(mar=c(4,4,.1,.1))
ggplot(without_ibed[!is.na(without_ibed$distance)],aes(log10(score)))+
  geom_density(fill="#69b3a2", color="#e9ecef",alpha=0.8)+
  ggtitle("Score distribution for data(Cis)")+
  geom_vline(xintercept = log10(5),color="grey")+
  annotate(x=log10(5),y=2,label="score=5",vjust=2,geom ="label")+
  theme_cowplot()

ggplot(without_ibed[is.na(without_ibed$distance)],aes(log10(score)))+
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)+
  ggtitle("Score distribution for data(Trans)")+
  geom_vline(xintercept = log10(5),color="grey")+
  annotate(x=log10(5),y=2,label="score=5",vjust=2,geom ="label")+
  theme_cowplot()
```

## Relation with score and distance

```{r}
p1 = ggplot(chic_signif_cis %>% arrange(count),aes(x=distance,y=log(score,base=10)))+
  geom_point(aes(color=count),size=0.5,alpha=0.3)+
    scale_colour_viridis()+
    xlab("distance")+
  ylab("log10 score")+
  theme_cowplot()+
  ggtitle("score distribution of significant interactions")+
  theme(plot.title = element_text(size = 10))+
  geom_hline(yintercept = log10(5),color="red")+
  annotate(y=log10(5),x=1.0e+08,label="score=5",vjust=2,geom ="label")


p2 = ggplot(wo_mn[wo_mn$score>5] %>% arrange(count),aes(x=distance,y=log(score,base=10)))+
  geom_point(aes(color=count),size=0.5,alpha=0.3)+
    scale_colour_viridis()+
    xlab("distance")+
  ylab("log10 score")+
  theme_cowplot()+
  ggtitle("score distribution of significant interactions without MALAT1 and NEAT1")+
  theme(plot.title = element_text(size = 10))+
  geom_hline(yintercept = log10(5),color="red")+
  annotate(y=log10(5),x=1.0e+08,label="score=5",vjust=2,geom ="label")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)


slickR(list(p1, p2))+settings(dots=TRUE,autoplay = TRUE)
```


# Bait to bait interactions
There are a total of `r length(unique(ibed$bait.id))` unique baits detected in the interactions and a total of `r length(unique(ibed$target.id))` unique other ends. However out of these other ends `r length(unique(ibed[!ibed$target.id %in% ibed$bait.id]$target.id))` are unique otherEnds such that they are also not a bait. Similarly there are `r length(unique(ibed[!ibed$bait.id %in% ibed$target.id]$bait.id))` baits which are not also an otherEnd. These are the interactions which correspond to non-bait to bait interactions. For otherEnds which are not baits we can compare the relationship with q.value,counts and the length of the otherEnd.

## Frag.length

```{r,fig.cap="non bait-to-bait interactions"}
ggplot(ibed[!ibed$target.id %in% ibed$bait.id],aes(x=frag.len,y=log10(q.value),color=log10(count)))+
  geom_point(size=0.3,alpha=0.3)+
  scale_color_viridis()+
  theme_cowplot()+
  ggtitle("OtherEnd length vs q.value")
```

```{r}
ggplot(ibed[!ibed$target.id %in% ibed$bait.id],aes(x=frag.len,y=count))+
  geom_point(size=0.3,alpha=0.3,color="#69b3a2")+
  theme_cowplot()
```

## Bait Length
```{r}

ibed$bait.len <- ibed$bait.end-ibed$bait.start
ggplot(ibed[!ibed$target.id %in% ibed$bait.id],aes(x=bait.len,y=log10(q.value),color=log10(count)))+
  geom_point(size=0.3,alpha=0.3)+
  scale_color_viridis()+
  theme_cowplot()+
  ggtitle("Bait length vs q.value")
```




# Comparison with previous plots

Previously we had seen certain plots which stood out when looking at the relationship between the probability of detecting an interaction and the distance. We compare these plots with the current q.value distribution.

## MALAT1

```{r}
#MALAT1

ibed <- ibed[!is.na(distance)]
MALAT1 <- ibed[ibed$bait_name=="MALAT1"]
MALAT1 <- MALAT1[is.na(MALAT1$distance)]
q.count <- quantile(MALAT1$count,c(0.30,0.60,0.90,0.95))
MALAT1$q.count <- with(MALAT1,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(MALAT1,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("MALAT1")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()
setorder(MALAT1,q.count)
p2 = ggplot(MALAT1 ,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+
    ggtitle("MALAT1")+
    theme_cowplot()+
    ylab("log(q.value)")
p3 = ggplot(MALAT1 ,aes(x=distance,y=score))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+
    ggtitle("MALAT1")+
    theme_cowplot()+
    ylab("score")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
p3 = xmlSVG({show(p3)}, standalone = TRUE)  

slickR(list(p1, p2,p3))+settings(dots=TRUE,autoplay = TRUE)
```

## RNVU1-7

```{r}
#RNVU1-7
RNVU1 <- ibed[ibed$bait_name=="RNVU1-7"]
q.count <- quantile(RNVU1$count,c(0.30,0.60,0.90,0.95))
RNVU1$q.count <- with(RNVU1,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))


p1 = ggplot(RNVU1,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("RNVU1-7")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()
setorder(RNVU1,q.count)
p2 = ggplot(RNVU1 ,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","red"),labels=c("60-90","95-100"))+
    ggtitle("RNVU1-7")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2))+settings(dots=TRUE,autoplay = TRUE)
```

## RMRP

```{r}
#RMRP
RMRP <- ibed[ibed$bait_name=="RMRP"]
q.count <- quantile(RMRP$count,c(0.30,0.60,0.90,0.95))
RMRP$q.count <- with(RMRP,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(RMRP,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("RMRP")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()
setorder(RMRP,q.count)
p2 = ggplot(RMRP,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("darkgoldenrod4","coral1","red"),labels=c("60-90","90-95","95-100"))+
    ggtitle("RMRP")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) +settings(dots=TRUE,autoplay = TRUE)
```

## EBF1

```{r}
#EBF1
EBF1 <- ibed[ibed$bait_name=="EBF1"]
q.count <- quantile(EBF1$count,c(0.30,0.60,0.90,0.95))
EBF1$q.count <- with(EBF1,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 =ggplot(EBF1,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("EBF1")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(EBF1,q.count)
p2 = ggplot(EBF1,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+ 
    ggtitle("EBF1")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) +settings(dots=TRUE,autoplay = TRUE)
```

## TENM4

```{r}
#TENM4
TENM4 <- ibed[ibed$bait_name=="TENM4"]
q.count <- quantile(TENM4$count,c(0.30,0.60,0.90,0.95))
TENM4$q.count <- with(TENM4,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(TENM4,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("TENM4")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(TENM4,q.count)
p2 = ggplot(TENM4,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+
    ggtitle("TENM4")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2))+settings(dots=TRUE,autoplay = TRUE)
```

## NEAT1

```{r}
#NEAT1
NEAT1 <- ibed[ibed$bait_name=="NEAT1"]
NEAT1 <- NEAT1[is.na(NEAT1$distance)]
q.count <- quantile(NEAT1$count,c(0.30,0.60,0.90,0.95))
NEAT1$q.count <- with(NEAT1,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(NEAT1,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("NEAT1")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(NEAT1,q.count)
p2 = ggplot(NEAT1,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+ 
    ggtitle("NEAT1")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) + settings(dots = TRUE, autoplay = TRUE)
```

## EHBP1

```{r}
#EHBP1
EHBP1 <- ibed[ibed$bait_name=="EHBP1"]
EHBP1 <- EHBP1[!is.na(EHBP1$distance)]
q.count <- quantile(EHBP1$count,c(0.30,0.60,0.90,0.95))
EHBP1$q.count <- with(EHBP1,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(EHBP1,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("EHBP1")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(EHBP1,q.count)
p2 = ggplot(EHBP1,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_viridis(name="percentile of counts",
                   discrete=TRUE,labels=c("0-30","30-60","60-90","90-95","95-100"))+
    ggtitle("EHBP1")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) + settings(dots = TRUE, autoplay = TRUE)  
```

## PDE3B

```{r}
#PDE3B
PDE3B <- ibed[ibed$bait_name=="PDE3B"]
q.count <- quantile(PDE3B$count,c(0.30,0.60,0.90,0.95))
PDE3B$q.count <- with(PDE3B,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(PDE3B,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("PDE3B")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(PDE3B,q.count)
p2 =ggplot(PDE3B,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("black","darkgoldenrod4","green","red"),labels=c("30-60","60-90","90-95","95-100"))+ 
    ggtitle("PDE3B")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) + settings(dots = TRUE, autoplay = TRUE)
```

## DAB1

```{r,fig.show="hold",out.width="50%",fig.cap="DAB1 "}
#DAB1

DAB1 <- ibed[ibed$bait_name=="DAB1"]
q.count <- quantile(DAB1$count,c(0.30,0.60,0.90,0.95))
DAB1$q.count <- with(DAB1,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(DAB1,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("DAB1")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(DAB1,q.count)
p2 = ggplot(DAB1,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("black","darkgoldenrod4","coral1","red"),labels=c("30-60","60-90","90-95","95-100"))+
    ggtitle("DAB1")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) + settings(dots = TRUE, autoplay = TRUE)
```

## KIF20B

```{r}
KIF20B <- ibed[ibed$bait_name=="KIF20B"]
KIF20B <- KIF20B[!is.na(KIF20B$distance)]
q.count <- quantile(KIF20B$count,c(0.30,0.60,0.90,0.95))
KIF20B$q.count <- with(KIF20B,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(KIF20B,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("KIF20B")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(KIF20B,q.count)
p2 = ggplot(KIF20B,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_viridis(name="percentile of counts",
                         discrete = TRUE,
                    labels=c("0-30","30-60","60-90","90-95","95-100"))+
    ggtitle("KIF20B")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) + settings(dots = TRUE, autoplay = TRUE)
```

## PCDH9

```{r}
#KIF20B
PCDH9 <- ibed[ibed$bait_name=="PCDH9"]
PCDH9 <- PCDH9[!is.na(PCDH9$distance)]
q.count <- quantile(PCDH9$count,c(0.30,0.60,0.90,0.95))
PCDH9$q.count <- with(PCDH9,ifelse(count<q.count[1],0,
                                 ifelse(count<q.count[2],1,
                                  ifelse(count<q.count[3],2,
                                  ifelse(count<q.count[4],3,4)))))

#dist
p1 = ggplot(PCDH9,aes(distance))+
  geom_histogram(fill="#69b3a2",aes(y = stat(count)/sum(count)))+
  scale_y_continuous(labels = scales::percent)+
  ggtitle("PCDH9")+
  xlab("Distance of interaction")+
  ylab("Probability")+
  theme_cowplot()

setorder(PCDH9,q.count)
p2 = ggplot(PCDH9,aes(x=distance,y=log(q.value,base=10)))+
    geom_point(aes(color=as.factor(q.count)),size=0.5,alpha=0.3)+
    scale_colour_manual(name="percentile of counts",
                    values=c("#69b3a2","black","darkgoldenrod4","coral1","red"),labels=c("0-30","30-60","60-90","90-95","95-100"))+
    ggtitle("PCDH9")+
    theme_cowplot()+
    ylab("log(q.value)")

p1 = xmlSVG({show(p1)}, standalone = TRUE)  
p2 = xmlSVG({show(p2)}, standalone = TRUE)  
slickR(list(p1, p2)) + settings(dots = TRUE, autoplay = TRUE)
```


```{r,echo=FALSE,message=FALSE,results='hide'}
rm(MALAT1)
rm(ibed)
gc()
```
